# Github作成
 * Githabページに自身のディレクトリを作成
 * docディレクトリ配下にmdファイルを格納する想定。

# SPAに関する理解

## ハンズオン環境構築
https://www.amazon.co.jp/%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E3%81%A4%E3%81%8F%E3%82%8BReact%E3%82%A2%E3%83%97%E3%83%AA-TypeScript-mod728-ebook/dp/B094Z1R281
　
1. フォルダ作成
1. vs code ダウンロード
1. nodejsインストール
  3.1. 下記のURLにアクセスし、OSに適用するインストーラーをダウンロード
　　https://nodejs.org/en/download/
  3.2. ダウンロードしたインストーラーをダブルクリックで実行
　　インストール画面でNextを数回クリック→Install→Finish
1. npx create-react-app XXX　フォルダを作成
1. src構成は以下
　src
  |-App.css
  |-App.test.tsx
  |-App.tsx
  |-index.css
  |-index.tsx
  |-logo.svg
  |-react-app-env.d.ts
  ・・・
1. 上記は基本不要フォルダ

### 従来のWebシステムとSPAの違い

SPA（ Single Page Application ）とは、初めに単一のHTMLをロードし、その後はJavaScriptがサーバサイドからデータを取得してビューを生成する手法。
SPAではHTMLは一つでJavascriptまたはDOMの書き換えで画面遷移を実現するのが基本。


期待できる効果は以下
* 初回アクセス時に、アプリケーション全体で必要な静的コンテンツをすべてダウンロードする。初回アクセス以降は、サーバサイドでHTMLを出力せずにデータ（JSON）のみを出力し、クライント側でデータをもとにDOM操作することで部分的に画面遷移を行う。　
* 更新箇所のみをサーバサイドにリクエストするため、サーバサイドとの通信量が減少し、クライアント画面での動作速度向上が期待できる。

* フロントエンドとバックエンドを分離したアーキテクチャとすることで、バックエンドの影響にしばられず、フロントエンドを作りこむことが可能となる。
* 他システムからAPIで取得した情報を画面出力させて、一体のサービスとしてユーザーに提供することができる。
* バックエンドとフロントエンドが独立しているため、モバイル機能なども、フロントエンドを作りこむのみで、バックエンドについては流用可能となる。
* プッシュ通知等、ネイティブアプリで実装されるような機能も実現することができる。

### React用語
以下に自分の理解を記述する。
#### Props
上位コンポーネントから値を引きつぐ時に利用する。
下位コンポーネントは上位から引き継いだ値をもとに画面出力を変更する。

#### State
各コンポーネントが保持している、状態を表すもの。
例：プルダウンの選択肢や、一覧表示データ等

ただし、下位コンポーネントは上位コンポーネントデータを更新ができないため、
そのときは、上位コンポーネントが保持している関数を呼び出すことで上位
コンポーネントのstateを上書きすることができる。
上位コンポーネントはstateが書き換えられたことに起因してカスタムフックなどで
APIを呼び出すことができ、呼び出し結果をPropsとして下位テーブルコンポーネントなどに渡すことで
一覧テーブルを更新できる。

#### Render
コンポーネントの要素をどのようにレンダリングするか決定する部分。
従来のHTMLの要にXML形式で記述可能。
Material UIを利用することで簡易的に実装ができる。


#### Hook
Stateを更新するもの。Hookの種類は複数存在し、Reactのページを見ると記述されている。
https://ja.reactjs.org/docs/hooks-intro.html
Hookの便利な点は、クラスを書かずにStateを変更できる点と、
テストを見据えた際に、自動化する際に、Hook部分を埋め込みできるため簡単にテスト自動化ができる。


#### APIの発火方法
stateが変わることに伴いカスタムフック(APIに紐づく)

### 設計書作成方針
どこにもReactフロントエンド設計書サンプルがないため、以下方針で設計書を作成するとよいと考える。
1. コンポーネント毎に、Props、State、Hookを定義
1. State状態に紐づく画面状態を可視化するディシジョンツリーを作成する。
1. APIは基本カスタムフックで作成する方が将来的に自動化する場合や、ソースの可読性としてよい。
1. コンテキストプロバイダーとカスタムフックは一覧化しておく。
1. 共通コンポーネントを先に設計し、個別コンポーネント設計にうつる方が手戻りが少ない

## API実装

---
title: API設計
linkTitle: 
weight: 7
---

## API設計

### 目的  

本システムでは、フロントエンド、バックエンド間の疎結合化を目指し、バックエンドの再利用性向上のためにWebAPI化を行う。
また、将来的なサービスの成長を見込み、WebAPIのOpenAPI化も視野にいれた設計を行う必要がある。
このため本章では、WebAPIの設計方針を定義することで将来拡張性を見据えた設計を目的とする。

> 本章作成にあたり、[API公開ガイドライン](https://www.swh.groupwide.net/swh/tips/cid/T2017-10-17-009)を参考に本プロジェクトにて重要な部分や独自の方針を記載している。


### アーキテクチャ概要

本章では、本システムで採用するアーキテクチャスタイルである、RESTおよびリソース指向アーキテクチャの概要と特性を示す。

#### RESTful Web Service

RESTとは、「REpresentational State Transfer」の略であり、クライアントとサーバ間でデータをやりとりするアプリケーションを構築するために用いられるアーキテクチャスタイルの1つである。
RESTのアーキテクチャスタイルに従っているもの(システムなど)は RESTfulと表現される。
「RESTful Web Service」とは、RESTのアーキテクチャスタイルに従って構築されているWeb Serviceという事になる。

RESTful Web Serviceの重要な特徴は、HTTP プロトコルの定義 ( RFC 2616 - Hypertext TransferProtocol — HTTP/1.1) に従って 明示的に HTTP メソッドを使うことである。
この特徴に基づいて、個別のWebサービスやWeb APIがRESTfulになることが、Web全体としてより良くなるという思想がある。

本システムでは将来的なOpenAPI化を見据えて、この思想に従いRESTful Web Serviceを目指したAPI設計を行う。

#### リソース指向アーキテクチャ

RESTful Web Serviceを構築するためのアーキテクチャであるリソース指向アーキテクチャ(ROA)が、「RESTful Web サービス」(Leonard Richardson, O’Reilly, 2007.12.18)にて提唱されている。
ROAは、「Resource Oriented Architecture」の略である。RESTのアーキテクチャスタイル(原則)に従ったWeb Serviceを構築するための具体的なアーキテクチャを提唱している。
RESTful形式のAPIを設計するに際には、ROAがもつ4つの特性(アドレス可能性、ステートレス性、接続性、統一インターフェース)を考慮する必要がある。
ただし、必ずすべてを適用しなくてはいけないということではなく、開発するアプリケーションの特性を考慮し、必要なものを適用すればよい。

|特性|概要|
|---|---|
|アドレス可能性|URIを使用してWeb上のリソースにアクセスできる状態になっていること|
|ステートレス性|サーバ上でアプリケーションの状態を保持しないこと|
|接続性|リソース同士が相互にリンクを保持し、リンクをたどることでアクセスできる状態になっていること|
|統一インターフェース|URIで指定したリソースに対する操作を、統一された用途に準じたHTTPメソッドで行うこと|

* アドレス可能性
ROAでは、URIを使用してWeb上のリソースにアクセスできる状態になっていることを「アドレス可能性」と呼んでいる。
これは同じURIを使用すれば、どこからでも同じリソースにアクセスできる状態になっており、まだ存在しないリソースに対してもURIを使用して作成可能であることを意味している。
API設計時には、リソースに対して適切なURIを設計し、APIとして利用者に公開することで、アドレス可能性を満たすことが可能である。

* ステートレス性
ROAでは、サーバ上でアプリケーションの状態を保持しないことを「ステートレス性」と呼んでいる。
「ステートレス性」を満たすとは、クライアントが必要なリソースにアクセスするために、アプリケーションサーバのHTTPセッション等を特定の状態へ移行させる必要がないことを意味する。 
つまり、「ステートレス性」を満たす状態とは、リクエストされた情報のみでリソースに対する操作が完結できる状態である。
API設計時には、1リクエストで処理が完結するよう設計することでステートレス性を満たすことが可能である。

* 接続性
ROAでは、リソース同士が相互にリンクを保持し、リンクをたどることでアクセスできる状態になっていることを「接続性」と呼んでいる。
これは、関連をもつリソース同士が相互にリンクを保持し、そのリンクをたどることで関連するすべてのリソースにアクセスできる状態にしておくことを意味している。
API設計時には、接続性を考慮したアーキテクチャ(HATEOASなど)を利用することで接続性を満たすことが可能である。

* 統一インターフェース
ROAでは、URIで指定したリソースに対する操作を、統一された用途に準じたHTTPメソッドで行うことを「統一インターフェース」と呼んでいる。
「統一インターフェース」とは、Web上で公開されるすべてのリソースに対してHTTPメソッドで操作でき、且つリソースごとにHTTPメソッドの意味が変わらないことである。すべてのサービスがHTTPのインターフェースを同じ方法で使用し、統一することが重要である。
API設計時に、HTTPメソッドの方針に従うことで、統一インターフェースの特性を満たすことが可能である。


本システムでは、ROAの基本となるアドレス可能性、ステートレス性、統一インターフェースを適用する。
一方で、ROAの拡張的な特性である接続性は重視しない方針とする。

### API設計方針

本章では、前章のアーキテクチャを実現するために、APIのリクエストとレスポンスを使用する際のインターフェース仕様の設計方針について示す。

APIに対するリクエストはリクエスト部、ヘッダ部、ボディ部に分けられる。 
APIに対するレスポンスはレスポンス部、ヘッダ部、ボディ部に分けられる。 

#### 共通リクエスト、レスポンス

本章では、APIのリクエストとレスポンスとで共通する方針を記述する。

##### 冪等性保証

APIアーキテクチャの設計資料参照

##### セッション

APIアーキテクチャの設計資料参照

##### キャッシュ

APIアーキテクチャの設計資料参照

##### 非同期

APIアーキテクチャの設計資料参照
非同期動作を行うためには、アプリが処理ステータス情報を取得するためのAPIを用意し、そのAPIを実行した結果処理が完了していたら所望の結果が返るようにするべきである。また、非同期処理の完了時にクライアントへ処理完了を通知するパターンも存在する。 処理ステータス情報の取得から処理結果の確認までの例を以下に示す。

レスポンスのLocationヘッダに処理ステータス情報を取得するAPIを設定する。

* 非同期動作実行時のレスポンス
    > HTTP/1.1 202 Accepted
    > Location:https://api.example/v1/operations/123
    > Retry-After:30
    > LocationヘッダのAPIから処理ステータス情報を確認する。

* 処理ステータス情報の取得
    > GET https://api.example/v1/operations/123

処理中の場合、以下ように処理が継続していることがわかる処理ステータス情報を返す。

* 処理ステータス情報(未完了の場合)
    > HTTP/1.1 200 OK
    > Retry-After:30
    > ```json
    > {
    >   "createdDateTime": "2015-06-19T12-01-03.45Z",
    >   "status":"running"
    > }
    > ```

処理が完了している場合、以下のように処理が正常終了し作成したリソースのURIを示す内容を返す。

* 処理ステータス情報(完了の場合)
    > HTTP/1.1 200 OK
    > Content-Type: application/json
    > ```json
    > {
    >   "createdDateTime":"2015-06-19T12-01-03.45Z",
    >   "lastActionDateTime":"2015-06-19T12-06-03.0024Z",
    >   "status":"succeeded",
    >   "resourceLocation":"https://api.example/v1/databases/db1"
    > }
    > ```

#### リクエスト部

本章では、APIに対するリクエストの際に記載するリクエスト部、リクエストヘッダ部、リクエストボディ部についての設計方針を示す。

##### HTTPメソッド

HTTPメソッドは、原則以下のCRUD(Create-Read-Update-Delete)を満たすHTTPメソッドを使用する。

|CRUD|HTTPメソッド名|用途|操作が保証すべき特性|
|---|---|---|---|
|Create|POST|リソースを新規に作成・承認・差戻・取消|-|
|Read|GET|リソース情報の参照|安全性、冪等性|
|Update|PUT|リソースの更新|冪等性|
|Update|PATCH|使用しない|-|
|Delete|DELETE|リソースの削除|冪等性|

なお、同一リソースに対する操作は、同一のURIに対し適切なHTTPメソッドにより操作する。
> たとえば、ユーザ情報のCRUD操作を行う場合には、以下のように同一URIを指定する。
> * ユーザの新規作成
> `POST http://api.example.com/v1/users`
> * ユーザ情報の取得
> `GET http://api.example.com/v1/users/1`
> * ユーザ情報の更新
> `PUT http://api.example.com/v1/users/1`
> * ユーザ情報の承認
> `POST http://api.example.com/v1/users/1`
> * ユーザ情報の削除
> `DELETE http://api.example.com/v1/users/1`
> 
>> PUTメソッドを使用してユーザ情報の削除を行うなど、あるHTTPメソッドを使って別のHTTPメソッド動作を行ってはならない。

HTTPの制約上実現できない場合もしくは上記に該当しない場合、`POST`メソッドを使用すること。
以下の表にHTTPメソッド規定外の使用例を示す。

|条件| 使用方法|
|---|---|
|特定のリソースを移動するなどCRUDで表せないリソース操作を行う場合| POSTを使用|
|クエリパラメータ含むURIの長さが2083文字を超える可能性がある場合| POSTを使用|
|既存システムの制約により使用できないHTTPメソッドが存在する場合| POSTを使用|

##### URI

基本的なURIの形式、URIに記載するホスト名、API名、リソース名、メジャーバージョン、マイナーバージョンの命名規則について記載する。

本節ではURIを構成する要素を、以下のように記述する。

|構成要素名|意味|例|
|---|---|---|
|ホスト名|サーバホストの名称|api.example.com|
|メジャーバージョン|APIのメジャーバージョン|v1|
|API名|API公開単位ごとの名称<br>サブシステム単位など|apiName|
|リソースパス|リソースを特定するパス|/users/1|

* URI形式
    URIにメジャーバージョンとAPI名を含めた以下の形式を採用する。
    [ホスト名]/api/[API名]/[メジャーバージョン]/{リソースパス}
    > 例
    > `http://api.example.com/api/apiName/v1/users`

* メジャーバージョン
    URIに記載するバージョンはメジャーバージョンのみ記載し、「v + 整数」で記載する。
    > メジャーバージョンの命名規則
    > `v1, v2, ...`

* URI命名規則
    * URIの表記すべてで先頭小文字のキャメルケースを採用する。
    * スペースやエンコードを必要とする文字を使用しない。
        単体で意味がわかるようにURIを設計するのが望ましいため、このような文字の使用は避ける。
        > [URI予約文字](https://tools.ietf.org/html/rfc3986)

* API名
    API名はドメイン分割単位やサブシステム単位で命名する。

* リソース名
    リソースは名詞で命名し、複数形を用いること。
    リソースの実態が理解できる範囲でなるべく名詞の抽象度を上げることが望ましい。

##### クエリーパラメータ

URIとクエリパラメータの使い分け、クエリパラメータ名の命名規則、複数パラメータ値の指定、階層的パラメータの指定方法について記載する。

* クエリーパラメータの使い分け
    パラメータをURIのパスに含めるか、クエリパラメータとするかの判断は以下の基準に従うこと。

    |条件|指定方法|
    |---|---|
    |一意なリソースを表すのに必要な情報である場合|URI|
    |リソースの状態を表す情報である場合|クエリーパラメータ|
    |省略しても影響がない場合|クエリーパラメータ|

    リソースの状態を表す情報は、検索条件などに利用される。 
    > たとえば、管理者権限をもつユーザを検索する場合の検索条件は、クエリパラメータで指定すべきである。
    > `GET http://api.example.com/v1/apiName/users?role=super`

    省略可能とは、ページネーションのoffsetや、limitなどのように 省略時にはデフォルトの値を使用するような場合の動作が保証されている設計であること意味する。


* クエリパラメータ名の命名規則
    クエリパラメータ名の命名規則は、URI形式と同様にすべて先頭小文字のキャメルケース、スペースやエンコードを必要とする文字を使用してはならない。
    > クエリパラメータの設定例
    > `GET http://api.example.com/v1/apiName/products?productsId=1`

* 複数パラメータ値の指定
    クエリパラメータに値を複数指定する際、ANDで指定する場合とORで指定する場合について以下の指定方法をすべきである。
    * ANDの場合
        [パラメータ名]=[パラメータ値1]&[パラメータ名]=[パラメータ値2]&…
        > `http://api.example.com/v1/apiName/users?role=super&unit=compA`
    * ORの場合
        [パラメータ名]=[パラメータ値1],[パラメータ値2],…
        > `http://api.example.com/v1/apiName/users?role=super,unit=compA`

* 階層的パラメータの指定方法
    クエリパラメータにサーバ側が受け付けるパラメータを階層的に指定する必要がある場合、以下のようにドット(.)で区切って指定する。
    * address配下のpostCodeを指定したい場合
        [階層1].[階層2]…=[パラメータ値1]
        > `http://api.example.com/v1/apiName/users?address.postCode=1808585`

* レスポンスパラメータの指定方法
    リクエスト時にレスポンスパラメータを指定しなければ、すべてのパラメータをレスポンスする。 しかし、一部のレスポンスパラメータのみを返して欲しい場合、以下のように指定できる。
    * レスポンスパラメータの指定方法
        fields=[レスポンスパラメータ名1],[レスポンスパラメータ名2],…
        > `GET http://api.example.com/v1/apiName/users/1?fields=name,age`

* ページネーション
    本システムでは、一覧の上限数を超えた場合にページネーションを行う。
    ただし、ページの上限数は固定としクエリパラメータでの指定は行わない。
    ページネーションの返却値には、対応するデータに加えて取得対象の総件数を返却することで、フロント側で最大ページ数を特定できるようにする。
    ページ数の指定がない場合は1ページ目として扱う。
    * ページの指定方法
        offset=[ページ数]
        > `GET http://api.example.com/v1/apiName/users?offset=3`

* ソート
    本システムでは、単一のソートキーによる昇順・降順のソートのみ対応する。
    ソートキーとソート順序を指定する、`asc`(昇順)、`desc`(降順)をクエリパラメータに指定する。
    ソート順序の指定がない場合は昇順として扱う。
    * ソートの指定方法
        sortKey=[ソートキー]&sortOrder=[`asc`|`desc`]
        > `GET http://api.example.com/v1/apiName/users?sortKey=name&sortOrder=asc`



#### リクエストヘッダ部

基本的には、APIごとで独自のリクエストヘッダを使用しない方針とする。
なお、リクエストとレスポンスに共通するヘッダ部の使用ルールはヘッダ部の共通項目に示す。

独自のHTTPヘッダを規定する場合は下記の命名規則に従うこと。

* リクエストヘッダの命名規則
    案件独自のHTTPヘッダを定義する場合には、"X-"の接頭辞を付与したヘッダ名とする。
    > 独自ヘッダの例
    > `X-Request-Id: HY98X90YAX`

#### リクエストボディ部

リクエストボディはAPIごとに自由に定義してよい。
方針としては、application/jsonでの定義を基本とし、ファイルアップロードAPIなど該当しないものは個別にリクエストボディを定義する。

なお、リクエストとレスポンスに共通するボディ部の使用ルールはボディ部の共通項目に示す。

#### レスポンス部

##### ステータスコード

本システムでは、許容するステータスコードを規定し、各ステータスコードの使用ルールに従って使い分けることとする。
以下に規定するコード番号とそれぞれの使用ルールについて示す。

* 規定コードと使用ルール
    ステータスコードは使用ルールの表から使用する。
    種別としては、正常動作(2xx)、リダイレクション(3xx)、クライアント側エラー(4xx)、サーバ側エラー(5xx)とする。 
    * 正常動作(2xx)
        リクエストが成功し、動作が完了する場合にレスポンスされる。同期処理の場合200、非同期処理の場合202を返却する。
    * リダイレクション(3xx)
        リクエストを完了するための追加的な処理が必要の場合(例：リダイレクション動作、キャッシュ動作等)にレスポンスされる。特にリダイレクション(3xx)では規定したもの以外のステータスも存在するが、クライアント側でのハンドリングが必要になるなど、重要度が高いと考えるものについて規定している。 
    * クライアント側エラー(4xx)
        基本となる400に加え、ROAを実現する上で重要な要素であるURI、メソッド、認証認可に関してエラーを規定した。なお業務エラーの場合、4xxのステータスコードが適当であるが、正常に処理が完了した結果のエラーとして正常動作(2xx)を利用し、エラーメッセージを返却してもよい。

    ステータスコードの使用ルールは下記の表に従うこと。

    |コード|補足メッセージ|利用場面|関連メソッド|レスポンス|
    |---|---|---|---|---|
    |200|OK|リクエストが成功した場合のデフォルトレスポンス|すべて||
    |202|Accepted|リクエストは受け付けたがレスポンスが返るまで時間がかかる場合||ヘッダ：Location, Retry-After|
    |302|Found|リダイレクト処理を行う場合|すべて|ヘッダ：Location<br>その他：Locationヘッダにリダイレクション先のURIを記載する|
    |400|Bad Request|クライアント側に何らかのエラーがある場合のデフォルトレスポンス|||
    |401|Unauthorized|クライアント側での認証エラーがあった場合<br>セッションがタイムアウトした場合|すべて||
    |403|Forbidden|アクセス権限のないAPIにアクセスしようとした場合|||
    |404|Not Found|指定したURIにリソースが存在しない場合|||
    |429|Too Many Requests|指定した時間内に多くのリクエストを送信した場合|すべて||
    |500|Internal Server Error|メンテナンス等サーバ側エラーがある場合のデフォルトレスポンス|すべて||

#### レスポンスヘッダ部

基本的には、APIごとで独自のリクエストヘッダを使用しない方針とする。
なお、リクエストとレスポンスに共通するヘッダ部の使用ルールはヘッダ部の共通項目に示す。

独自のHTTPヘッダを規定する場合は下記の命名規則に従うこと。

* レスポンスヘッダの命名規則
    案件独自のHTTPヘッダを定義する場合には、"X-"の接頭辞を付与したヘッダ名とする。
    > 独自ヘッダの例
    > `X-Request-Id: HY98X90YAX`

#### レスポンスボディ部

##### エラーメッセージ

4xxおよび5xxをレスポンスする場合のレスポンスボディを規定する。 

> エラーメッセージについては後工程で精査すること。
> 以下ガイドラインに記載のRFC 7807で定められた下記の表のエラーメッセージ。
> |項目 | エラー情報内容|
> |---|---|
> |type(必須) | エラーについての文書を提供する参照先を設定する。この項目が設定されていない場合は、"about:blank"としてみなされる。|
> |title(任意) | エラー種類の要約を設定する。ローカライズの目的以外で、問題発生の度に変更すべきではない。|
> |status(任意)| 中継するサーバによってステータスコードが変更された場合、本来のステータスコードを設定する。|
> |detail(任意) | エラーの説明文を設定する。|
> |instance(任意) | エラーの発生箇所を示すURIを設定する。|
> |拡張情報(任意) | 項目を追加してエラーについての詳細な情報を含めることができる。また、エラーメッセージは以下の例のようなJSON形式にてレスポンスする。|
> 例：エラーメッセージ
> ```json
> {
>   "type":"https://api.example.com/probs/out-of-credit",
>   "title":"You do not have enough credit.",
>   "status":400,
>   "detail":"Your current balance is 30, but that costs 50.",
>   "instance":"/account/12345/msgs/abc",
>   "balance":30,
>   "accounts":[
>   "/account/12345",
>   "/account/67890"
>   ]
> ```


#### API運用方針

##### APIバージョン管理

* バージョンアップ方針
    APIの仕様変更には、メジャーバージョンアップとマイナーバージョンアップがある。
    メジャーバージョンアップは、クライアントアプリに追加開発が必要な後方互換性が担保されないバージョンアップである。
    マイナーバージョンアップは、クライアントアプリの追加開発が不要な後方互換性が担保されるバージョンアップである。
    メジャーバージョンアップを行う場合は、以下の対応を行わなければならない。
    * メジャーバージョンをインクリメントする。
    * URIに含まれるメジャーバージョンを更新する。
    * バージョン変更によるAPI仕様変更箇所をAPIドキュメントに記載する。
    * 後方互換性を保つため、一定期間バージョンの並行運用を行うのが望ましい。

    マイナーチェンジによるバージョンアップ(マイナーバージョンアップ)を行う場合は、以下の対応を行わなければならない。
    * マイナーバージョンをインクリメントする。
    * バージョン変更によるAPI仕様変更箇所をAPIドキュメントに記載する。

    レスポンスで返却するデータの名前や形式を変更するような軽微な修正の場合には、 マイナーバージョンアップで対応すべきである。
    > 例として、レスポンスの形式変更するケースを示す。
    > レスポンスの形式変更をマイナーバージョンアップで対応する場合
    >> 性別genderという数値項目を男性は1、女性は2で表していたものを文字列maleとfemaleに変更する場合に、 genderの返却値を変更してしまうと、後方互換性が保たれずメジャーバージョンアップが必要になってしまう。
    >> genderは変更せず、genderStrという新規項目を追加し、maleとfemaleを返却する仕様としマイナーバージョンアップすれば、 後方互換性は維持したまま、文字列でのレスポンス形式に対応が可能となる。genderの廃止は、後方互換性の担保が不要なメジャーバージョンアップ時に実施する。

* バージョンの提供終了方針
    メジャーバージョンアップをする場合、APIごとにバージョンを管理し、バージョン移行の期間として並行運用期間を設けるのが望ましい。なぜならば、クライアントアプリ開発者またはユーザにとって多大なインパクト(クライアントアプリ追加開発、サービス停止等)を与えるためである。
    また、メジャーバージョンアップにより旧バージョンの公開終了する際には、以下のような仕様はあらかじめ盛り込んでおいた方がよい。
    * API公開終了時には、ステータスコード410を返却し、公開終了した旨のエラーメッセージを返却する。
    * クライアントのアップデートを促すため、アップデートさせるサイトにリダイレクトさせる。
    以上はあくまで一例である。案件に応じた仕様とすること。


##### OpenAPI Specificationの利用

本プロジェクトでは、API仕様の定義にOAS(OpenAPI Specification)を採用する。
OpenAPI Specificationとは、OAI(Open API Initiative)が策定しているRESTful APIを構築することを目的とした、APIのインターフェース定義の記述方法を標準化した仕様である。
OAIとは、APIの標準化を目的とし、MicrosoftやGoogleなどの企業によって結成された団体である。
OASには、OASに対応した多くのOSSツールやライブラリが存在する。
各種ツールと機能を以下に示す。

|ツール|機能|
|---|---|
|Swagger Editor| OpenAPI SpecificationでRESTfulAPIを設計、定義、および文書化するためのエディタ|
|Swagger UI| OpenAPISpecificationで記載した文書をレンダリングするためのツール|
|OpenAPI Generator| OpenAPISpecificationで定義されたRESTful APIから直接サーバスタブとクライアントSDKを構築するコードジェネレータ|
|Swagger Core| API実装コード(Java)からOpenAPISpecificationで記載された設計を自動生成するためのJavaライブラリのセット|

これらの機能を利用することで、APIドキュメントとソースコードに差異がないことを保証できる。また、API-GW製品との連携が可能である。





# AWS 環境構築
##　 AWS ECS上に構築するSpringアプリケーション(1) (5/2)

1. VPCの作成
https://news.mynavi.jp/itsearch/article/devsoft/4354¶
 * VPCは既存のものを流用する想定。



>困っていること：AWS運用ファイルを確認の上、課題4の中で、どれはやってよくてどれはだめなのか整理すること


1. パブリックサブネットとプライベートサブネットの作成
  > TODO : AWS前回フォルダが削除されているので再作成する予定

1. カスタムルートテーブルの作成／メインルートテーブルの設定
  > TODO : AWS前回フォルダが削除されているので再作成する予定

1. インターネットゲートウェイの作成／VPCへのアタッチ
 * インターネットGWは既存のものを流用する想定。

1. NATゲートウェイの設定／アタッチ
  > TODO : AWS前回フォルダが削除されているので再作成する予定



## AWS ECS上に構築するSpringアプリケーション(2) 

1. ALBの作成

1. ALBの設定

1. ロードバランサのセキュリティグループを作成する

1. ルーティングの設定

1. ターゲットグループの登録
1. パスベースのルーティング設定

## AWS ECS上に構築するSpringアプリケーション(3) 

1. pom作成
1. アプリケーション実装 

## AWS ECS上に構築するSpringアプリケーション(4) 
1. Dockerコンテナの作成／DockerHubへのプッシュ
1. Backendアプリケーションのプロジェクトに作成するDockerfile
1. BFF(Backend For Frontend)アプリケーションのプロジェクトに作成するDockerファイル

## AWS ECS上に構築するSpringアプリケーション(5) 
1. ECSクラスタの作成
1. アクセス許可を追加する

## AWS ECS上に構築するSpringアプリケーション(6)
1. ECSタスクの定義  
    1. ロールの作成
    1. 新しいタスク定義の作成

## AWS ECS上に構築するSpringアプリケーション(7)
1. ECSサービスの実行

## Amazon RDSにアクセスするSpringアプリケーション(1)
1. Amazon RDSの構築
1. ユーザー／認証情報の作成

## Amazon RDSにアクセスするSpringアプリケーション(2)
1. Spring Data JPAおよびSpring Cloud AWSの概要 読み込み
1. Mavenプロジェクトのpom.xml構築
1. クラスの実装
    * App
    * DomainConfig
    * JpaConfig
    * RDSConfig
    * SampleService
    * Xxxxx(Entity)
    * XxxxxRepository

## Amazon RDSにアクセスするSpringアプリケーション(3)

## Spring Data DynamoDBを用いたアプリケーション(1)

## Spring Data DynamoDBを用いたアプリケーション(2)

## Webアプリケーションからマイクロサービスを呼び出す実装(1)

## Webアプリケーションからマイクロサービスを呼び出す実装(2)

